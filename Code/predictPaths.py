# -*- coding: utf-8 -*-
"""
Created on Tue Nov 13 09:35:18 2018

@author: Stephen Downhower
"""

# Constants
filename = 'compData.pkl'
dataPath = 'C:\\Users\\sdownhowerAdmin\\Documents\\GitHub\\FallJungleProject\\Data\\'
endTime = 6

# Import Statements
import pandas as pd
import numpy as np

# Obtains the dataframe generated by the comparePaths.py script
compData = pd.read_pickle(dataPath + filename)

def definePath(coordinates):
    # Constructs a reference path from the given list of coordinates, and
    #   creates the contour map pertaining to the next predicted locaiton
    #
    # Example Inputs: definePath([[4000,6000]]); definePath([[4000,7000],[7500,4000]])
    
    # Initial Set Up
    compData = pd.read_pickle(dataPath + filename) # Reads in the data frame
    startMin = 2 # Assumes first position given is at the two minute position
    threshold = 750 # Can be adjusted; Thresholding will be removed soon
    endMin = len(coordinates) + startMin
    
    # Creates posData and adds minute position columns
    posData = compData[['matchId','pos']]
    
    for i in range(startMin, endMin + 1):
        posData['position'+str(i)] = list((j)[i - 1] for j in posData['pos'])
    
    # Compares the given coordinates to the positions of the queried paths and
    #   calculates the distance at each minute in a column
    for i in range(startMin, endMin):
        col = 'distance' + str(i)
        posData[col] = ''
        refPoint = np.array(coordinates[i-startMin])
        
        for j in range(0, len(posData)):
            testPoint = posData.iloc[j][i]
            posData.iat[j,posData.columns.get_loc(col)] = np.linalg.norm(refPoint-testPoint)
            
        posData = posData[posData[col] <= threshold]

    # Creates x and y position columns for the final predicted position column
    #   to prepare for contour plot creation
    posData['x_position' + str(endMin)] = list((j)[0] for j in posData['position'+str(endMin)])
    posData['y_position' + str(endMin)] = list((j)[1] for j in posData['position'+str(endMin)])

    # Plots the positions on a map of Summoner's Rift
    positions = []
    for i in range(startMin, endMin + 1):
        positions.append(list(posData['position' + str(i)].values))
    
    from srPlot import complexPlot
    complexPlot(positions, list(range(startMin, endMin + 1)), 'no', 3)
    
    # Creates a contour map for the predicted positions
    from contourMap import contourSetUp
    contourSetUp(posData['x_position' + str(endMin)].values, \
                         posData['y_position' + str(endMin)].values, 20)
    
    return posData
    
def resetPath(refPos):
    # Given a reference position array, rewrites the compData.pkl object based
    # on the new reference path
    compData = pd.read_pickle(dataPath + filename)
    compData = compData.drop(['distance'], axis = 1)
    distance = []
    matchIds = list(compData['matchId'].values)
    
    # Loops through each match, and updates the distance array accordingly
    from comparePaths import findDist
    for i in range(0, len(matchIds)):
        distance.append(findDist(refPos, compData[compData['matchId'] == matchIds[i]]['pos']))
    compData['distance'] = distance

    # Rewrites the dataframe to the .pkl object and returns the dataframe
    picklePath = dataPath + filename
    compData.to_pickle(picklePath)   
    
def nextPosition(startMin, endMin, threshold, size = 20):
    '''
    Finds all paths within a threshold distance of the reference path's 
    position at the startMin time position, and plots the similar path's start
    positions as well as the similar path's positions bewteen the startMin and
    endMin times
    '''
        
    # Creates posData and adds two new columns for startPositions and
    #   nextPositions based on the startMin input
    posData = compData[['matchId','pos','distance']]
    
    for i in range(startMin, endMin + 1):
        posData['position'+str(i)] = list((j)[i - 1] for j in posData['pos'])
    
    # Filters posData for only the distance values at the startMin by the value
    #   given in the threshold parameter
    for i in range(startMin, endMin):
        posData['distance' + str(i)] = list((j)[i - 1] for j in posData['distance'])
        posData = posData[posData['distance' + str(i)] <= threshold]

    # Creates x and y position columns for the final predicted position column
    #   to prepare for contour plot creation
    posData['x_position' + str(endMin)] = list((j)[0] for j in posData['position'+str(endMin)])
    posData['y_position' + str(endMin)] = list((j)[1] for j in posData['position'+str(endMin)])

    # Plots the startPositions and nextPositions on summoner's Rift
    #   blue = startingPositions
    #   green = nextPositions
    positions = []
    for i in range(startMin, endMin + 1):
        positions.append(list(posData['position' + str(i)].values))
    
    from srPlot import complexPlot
    complexPlot(positions, list(range(startMin, endMin + 1)), 'no', 3)
    
    # Creates a contour map for the predicted positions
    from contourMap import contourSetUp
    contourSetUp(posData['x_position' + str(endMin)].values, \
                         posData['y_position' + str(endMin)].values, size)
    
    return posData

def weightedNextPosition(startMin, endMin, threshold, size = 20):
    '''
    Finds all paths within a threshold distance of the reference path's 
    position at the startMin time position, and plots the similar path's start
    positions as well as the similar path's positions one minute from the start
    minute

    There is additional 'weight' column that includes an additional metric 
    in which the magnitude is representative of the strength of similarity to 
    the reference path
    '''
    
    # Creates posData and adds two new columns for startPositions and
    #   nextPositions based on the startMin input
    posData = compData[['matchId','pos','distance']]
    
    for i in range(startMin, endMin + 1):
        posData['position'+str(i)] = list((j)[i - 1] for j in posData['pos'])
    
    # Filters posData for only the distance values at the startMin by the value
    #   given in the threshold parameter
    posData['weight'] = 0
    
    for i in range(startMin, endMin):
        posData['distance' + str(i)] = list((j)[i - 1] for j in posData['distance'])
        posData = posData[posData['distance' + str(i)] <= threshold]
        posData['weight' + str(i)] = threshold - posData['distance' + str(i)]
        posData['weight'] = posData['weight'] + posData['weight' + str(i)]
        
    posData['weight'] = posData['weight']/(posData['weight'].max())
 
    # Creates x and y position columns for the final predicted position column
    #   to prepare for contour plot creation
    posData['x_position' + str(endMin)] = list((j)[0] for j in posData['position'+str(endMin)])
    posData['y_position' + str(endMin)] = list((j)[1] for j in posData['position'+str(endMin)])

    # Plots the startPositions and nextPositions on summoner's Rift
    #   blue = startingPositions
    #   green = nextPositions
    positions = []
    for i in range(startMin, endMin + 1):
        positions.append(list(posData['position' + str(i)].values))
        
    from srPlot import weightedPlot
    weightedPlot(positions, list(posData['weight'].values), \
                 list(range(startMin, endMin + 1)), 'no', 3)
    
    # Creates a contour map for the predicted positions
    from contourMap import contourSetUp
    contourSetUp(posData['x_position' + str(endMin)].values, \
                         posData['y_position' + str(endMin)].values, size)
    
    return posData